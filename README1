Бинарная куча — это структура данных, реализующая принцип полного бинарного дерева. При добавлении новый элемент помещается в конец и «поднимается» вверх, пока не займёт нужную позицию. Для извлечения минимального (или максимального) элемента он удаляется, а его место занимает последний элемент, который затем «опускается» вниз до правильной позиции.
Биномиальная куча состоит из набора биномиальных деревьев. При вставке создаётся новая куча с одним элементом, которая затем объединяется с основной. Ключевой операцией является слияние, при котором списки корней двух куч объединяются в один.
Куча Фибоначчи представляет собой коллекцию деревьев. Вставка элемента выполняется простым добавлением в кучу. Основные операции включают слияние двух куч и удаление минимума, при котором узел с наименьшим ключом удаляется из структуры.
Хеш-таблицы хранят данные в виде пар «ключ-значение». В отличие от древовидных структур, они реализуются на основе массивов и односвязных списков. Каждый элемент сохраняется по адресу, который вычисляется с помощью хеш-функции от его ключа.

Бинарная куча (на основе массива)
Python
В Python бинарную кучу можно реализовать как собственный класс или с применением модуля heapq. heapq поддерживает лишь минимальную кучу; для формирования максимальной можно инвертировать значения.
Пример применения:
Создание списка: [8, 3, 5, 1, 6, 2, 4, 7].
Преобразование списка в кучу: heapify().
Добавление элемента: heappush().
Извлечение минимального элемента: heappop().
C++
В C++ бинарную кучу реализуют как полное бинарное дерево. Её можно представить, используя std::vector.
Пример операций:
Добавление элемента: новый узел добавляется в конец и «поднимается» наверх, пока не будет выполнено свойство кучи.
Извлечение минимального элемента: корень кучи (минимальный элемент) извлекается, а последний узел перемещается на его место, после чего «опускается» вниз.
Удаление узла: узел заменяется последним элементом, затем восстанавливается свойство кучи.
Java
В Java двоичную кучу (Binary Heap) можно реализовать на базе массива.
Пример операций:
Вставка: новый элемент добавляется в конец массива, после чего свойство кучи восстанавливается путём «подъёма» узла.
Извлечение минимального элемента: корень кучи заменяется последним элементом, и свойство кучи восстанавливается через «просеивание вниз» из корневого узла.

Биномиальная куча
Python
Биномиальную кучу в Python можно реализовать через собственный класс, поскольку встроенной реализации не существует.
Особенности: Представляет собой набор биномиальных деревьев. Каждое дерево имеет различный размер. Это «сливаемая куча», что подразумевает наличие дополнительной операции слияния двух куч.
C++
В C++ биномиальную кучу реализуют как коллекцию биномиальных деревьев.
Пример операций:
Вставка: создаётся куча с одним узлом, которая затем объединяется с текущей.
Объединение: объединяются списки корней двух куч.
Извлечение минимума: извлекается узел с наименьшим ключом.
Java
Биномиальную кучу в Java можно реализовать без внешних библиотек на основе стандартных средств.
Пример операций:
Вставка: элемент вставляется в кучу.
Удаление минимума: узел с минимальным ключом удаляется.
Слияние: текущая куча объединяется с другой кучей.

Куча Фибоначчи
Python
В Python отсутствует встроенная структура данных «куча Фибоначчи». Существуют примеры для работы с числами Фибоначчи, которые являются последовательностью, где каждое число — это сумма двух предыдущих.
Пример: Рекурсивная функция для расчёта n-го числа Фибоначчи: fibonacci(n). Функция вызывает саму себя для n-1 и n-2.
C++
В C++ нет встроенной структуры «куча Фибоначчи», но можно создать реализации для хранения элементов, связанных с последовательностью Фибоначчи.
Пример: Реализация класса FibonacciHeap с операциями: insert(key), unite(other_heap), getMin, extractMin, decreaseKey(element, new_key) и deleteElement(element).
Java
В Java можно реализовать «кучу Фибоначчи» с помощью рекурсивного алгоритма.
Пример: Метод fibonacci(long n). Метод дважды вызывает себя для вычисления чисел Фибоначчи на позициях n-1 и n-2, а затем суммирует их. Базовый случай: если n равно 0 или 1, возвращается n.

Хеш-таблицы
Python
В Python хеш-таблицы реализованы через встроенный тип данных dict (словарь). Также можно создать собственную реализацию.
Пример использования словаря:
Добавление пары «ключ-значение»: hash_table['Ellie'] = 'July' или hash_table.set('Ellie', 'July').
Получение значения по ключу: hash_table['Ellie'] или hash_table.get('Alice').
Удаление записи: del hash_table['Bob'] или hash_table.remove('Bob').
Важно: в роли ключей применяются только неизменяемые типы данных (строки, числа, кортежи).
C++
В C++ хеш-таблицы доступны через стандартную библиотеку шаблонов (STL), к примеру, std::unordered_map. Также можно написать реализацию вручную.
Пример использования std::unordered_map:
Создание: unordered_map<string, int> umap;.
Вставка: umap["Peach"] = 10;.
Коллизии разрешаются методом цепочек.
Java
В Java для хеш-таблиц применяются классы Hashtable и HashMap. HashMap реализован на основе массива односвязных списков.
Пример использования HashMap:
Создание: HashMap<String, Integer> hashMap = new HashMap<>();.
Добавление: hashMap.put("Jack", 25);.
Получение: hashMap.get("Jack");.
Удаление: hashMap.remove("John");.
